function (logical)contains(string x, string y) {
  assert(length(x) == 1 & length(y) == 1, "x and y must be length 1");
  return length(strsplit(x, y)) > 1;
}

function (string)filename_str(string params) {
  out = "";
  for (i in seqAlong(params)) {
    v = params[i];
    val = executeLambda(v + ";");
    assert(!contains(asString(val), "..") & !contains(asString(val), "/"),
           "filename key/value cannot contain . or /!");
    out = out + v + val + "_";
  }
  return out;
}

function (object)param_dict(string params) {
  pd = Dictionary();
  for (i in seqAlong(params)) {
    v = params[i];
    val = executeLambda(v + ";");
    if (length(val) > 1) {
      val = paste(val, sep=",");
    }
    pd.setValue(v, val);
  }
  return pd;
}

function (float) standard_fitness(object ind, object mut_type) {
  muts = sim.mutationsOfType(mut_type);
  hh = mut_type.dominanceCoeff;
  ss = muts.selectionCoeff;
  nmuts1 = ind.genome1.mutationCountsInGenomes(muts);
  nmuts2 = ind.genome2.mutationCountsInGenomes(muts);
  muts = nmuts1 + nmuts2;
  hets = muts == 1;
  homs = muts == 2;
  return exp(sum(log(1 + hh*ss[hets])) + sum(log(1 + ss[homs])));
}

function (float) pop_fitness(object mut_type) {
  inds = sim.subpopulations.individuals;
  return sapply(inds, 'standard_fitness(applyValue, mut_type);');
}

function (float) pop_fitness(object mut_type) {
  inds = sim.subpopulations.individuals;
  return sapply(inds, 'standard_fitness(applyValue, mut_type);');
}


initialize() {
  initializeTreeSeq();
  defineConstant("seed", getSeed());
  defineConstant("metadata", Dictionary());

  defineConstant("segment_length", 10000);
  defineConstant("ntracking", 100);
  defineConstant("tracklen", 2);
  // region length = segment length + track regions + 1bp spacers
  defineConstant("region_length", segment_length + ntracking*tracklen + ntracking);
	
  if (exists("slimgui") | exists("defaults")) {
    defineConstant("seglen", 10000);
    defineConstant("rep", 0);
    defineConstant("rbp", 1e-8);
    defineConstant("recfrac", 0.001);
    defineConstant("N", 1000);
    defineConstant("s", -2e-2);
    defineConstant("mu", 1e-8);
    defineConstant("h", 0.5);    // deleterious dominance
	defineConstant("datadir", '');
  } else {
	defineConstant("datadir", '../data/slim_sims/segment/');
  }

  // == Runtime settings
  defineConstant("burnin", 10*N);
  defineConstant("endsim", burnin);

  metadata.setValue("N", N);
  metadata.setValue("s", s);
  metadata.setValue("h", h);
  metadata.setValue("mu", mu);
  metadata.setValue("rbp", rbp);
  metadata.setValue("recfrac", recfrac);
  metadata.setValue("tracklen", tracklen);
  metadata.setValue("segment_length", segment_length);
  metadata.setValue("region_length", region_length);

  // == File Output
  // this must be the same order as the bgs_params in the Snakefile
  filestr = filename_str(c('N', 'mu', 'h', 's', 'rbp', 'rep'));
  defineConstant("basename", "segment_" + filestr);
  defineConstant("treeseq_file", datadir + basename + "treeseq.tree");

  // == Mutations, Regions, and Recombination
  initializeMutationRate(mu);
  
  // segment deleterious mutations
  initializeMutationType("m1", h, "f", -s);

  // Neutral tracked region from [0, tracklen-1] with no mutation
  // followed by a 1bp spacer (this is a bit silly but we don't want any
  // mutation or recombination in that 1bp)

  // gene segment under selection
  initializeGenomicElementType("g1", m1, 1);
  initializeGenomicElement(g1, 0, segment_length-1);

  // construct the tracking regions
  //defineConstant("rate", 0.0);
  //rates = c(rbp, rep(c(rate, 0), ntracking));
  ends = c(segment_length-1, rep(c(1, tracklen), ntracking)); 
  spacer_ends = cumSum(ends)[ends == 1];
  print(ends);
  print(spacer_ends);
  defineConstant("spacers", spacer_ends);
  print(spacers);
  //spacer_ranges = sort(c(spacer_ends - 1, spacer_ends));
  //initializeRecombinationRate(rates, cumSum(ends));
  initializeRecombinationRate(0); // since handled in the recombination callback
}

recombination() {
  // we break this into figuring out the breakpoints for the 
  // tracking regions and selected segment separately
  X = 1-rbinom(ntracking, 1, recfrac);
  Y = 1-c(X[0], X[1:(length(X)-1)] == X[0:(length(X)-2)]);
  tracking_breakpoints = spacers[which(asLogical(Y))];
  segment_breakpoints = rdunif(rpois(1, rbp*segment_length), 0, segment_length-1);
  breakpoints = c(segment_breakpoints, tracking_breakpoints);
  //print(breakpoints);
  assert(all(breakpoints < region_length));
  return T;
}

1 {
  sim.addSubpop("p1", N);
  sim.rescheduleScriptBlock(s1, start=2, end=endsim);
  sim.rescheduleScriptBlock(s2, start=endsim, end=endsim);
}

s1 {
  if (sim.generation % N == 0) {
    cat(paste(sim.generation, "/", endsim, "\n"));
  }
}

s2 late() {
  // how many del mutations fixed?
  inds = p1.individuals;
  ndel_subs = inds.countOfMutationsOfType(m1);
  fixed_load = inds.sumOfMutationsOfType(m1);
  metadata.setValue("ndel_subs", sum(ndel_subs));
  metadata.setValue("fixed_load", sum(fixed_load));
  popfit = pop_fitness(m1);
  metadata.setValue("Ef", mean(popfit));
  metadata.setValue("Vf", var(popfit));
  sim.treeSeqOutput(treeseq_file, metadata=metadata);
}
