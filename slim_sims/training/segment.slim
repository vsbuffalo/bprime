initialize() {
  source("../utils.slim");
  initializeTreeSeq();
  if (!exists("rep")) {
    defineConstant("rep", 0);
  }
  defineConstant("seed", getSeed());
  defineConstant("metadata", Dictionary());
  defineConstant("tracklen", 10);
  if (!exists("name")) {
    defineConstant("name", "segment");
  }

  if (!exists("subdir")) {
    subdir = "";
  } else {
    defineConstant("subdir_", subdir + '/');
  }

  if (exists("slimgui") | exists("defaults")) {
    defineConstant("L", 10000);
    defineConstant("rbp", 1e-8);
    defineConstant("rf", 1e-8);
    defineConstant("N", 1000);
    defineConstant("s", 1e-2);
    defineConstant("mu", 1e-8);
    defineConstant("h", 0.5);    // deleterious dominance
	defineConstant("datadir", 'tests/');
	defineConstant("name", 'defaults');
  } else {
	defineConstant("datadir", '../../data/slim_sims/'+name+'/'+subdir_);
  }

  defineConstant("region_length", tracklen + L + 1);

  // == Runtime settings
  defineConstant("burnin", 10*N);
  defineConstant("endsim", burnin);

  metadata.setValue("N", N);
  metadata.setValue("s", s);
  metadata.setValue("h", h);
  metadata.setValue("sh", s*h);
  metadata.setValue("mu", mu);
  metadata.setValue("rf", rf);
  metadata.setValue("rbp", rbp);
  metadata.setValue("tracklen", tracklen);
  metadata.setValue("L", L);
  metadata.setValue("region_length", region_length);
  metadata.setValue("rep", rep);

  // == File Output
  // this must be the same order as the bgs_params in the Snakefile
  filestr = filename_str(c('N', 'mu', 's', 'h', 'rf', 'rbp', 'L', 'seed', 'rep'));
  defineConstant("basename", name + "_" + filestr);
  defineConstant("treeseq_file", datadir + basename + "treeseq.tree");

  // == Mutations, Regions, and Recombination
  initializeMutationRate(mu);
  
  // segment deleterious mutations
  initializeMutationType("m1", h, "f", 0.0);
  // if L == 0 (which we allow for training purposes) we set s = 0, since
  // we can't actually have this in SLiM, but it's equivalent to s = 0
  initializeMutationType("m2", h, "f", -s * asFloat(L > 0));

  // Neutral tracked region from [0, tracklen-1] with no mutation
  // followed by a 1bp spacer (this is a bit silly but we don't want any
  // mutation or recombination in that 1bp)

  // gene segment under selection
  // we need a slight safety guard here -- if L = 0, 
  // set a length to 1 -- selection handled with s above
  // otherwise tracklen can = tracklen + L which breaks stuff
  defineConstant("safe_L", max(1, L));
  initializeGenomicElementType("g1", m1, 1);
  initializeGenomicElementType("g2", m2, 1);
  initializeGenomicElement(g1, 0, tracklen-1);
  initializeGenomicElement(g2, tracklen, tracklen+safe_L);

  // recombination between segments
  // recombination between each bp from 0 to tracklen-1 is 0,
  // recombinaton rate between the basepair tracklen-1 / tracklen is rf,
  // recombinaton rate between tracklen / tracklen+1, tracklen+1 / tracklen+2, etc is rbp
  rec_rates = c(0, rf, rbp);
  rec_bins = c(tracklen-1,        // neutral region
               tracklen,          // 1bp free recombinaton spacer
               tracklen+safe_L);       // selected region
  initializeRecombinationRate(rec_rates, rec_bins);
}

1 {
  sim.addSubpop("p1", N);
  sim.rescheduleScriptBlock(s1, start=2, end=burnin);
  sim.rescheduleScriptBlock(s2, start=endsim, end=endsim);
}

s1 {
  // if (sim.generation % N == 0) 
  //   print(sim.generation);
}

s2 late() {
  // how many del mutations fixed?
  inds = p1.individuals;
  ndel_subs = length(sim.substitutions.mutationType == m2);
  fixed_load = sum(sim.substitutions[sim.substitutions.mutationType == m2].selectionCoeff);
  metadata.setValue("ndel_subs", sum(ndel_subs));
  metadata.setValue("fixed_load", sum(fixed_load));
  metadata.setValue("generations", sim.generation);
  popfit = pop_fitness(m2);
  metadata.setValue("Ef", mean(popfit));
  metadata.setValue("Vf", var(popfit));
  sim.treeSeqOutput(treeseq_file, metadata=metadata);
  print(treeseq_file);
}

