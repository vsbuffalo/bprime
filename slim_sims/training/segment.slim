// note in process of changing s, h to sh TODO

initialize() {
  source("../utils.slim");
  initializeTreeSeq();
  defineConstant("seed", getSeed());
  defineConstant("metadata", Dictionary());
  defineConstant("tracklen", 10);
  if (!exists("name")) {
    defineConstant("name", "segment");
  }

  if (!exists("subdir")) {
    subdir_ = "";
  } else {
    defineConstant("subdir_", subdir + '/');
  }

  if (exists("slimgui") | exists("defaults")) {
    defineConstant("L", 100);
    defineConstant("rbp", 1e-8);
    defineConstant("rf", 0.2);
    defineConstant("N", 1000);
    defineConstant("sh", 1e-2);
    defineConstant("mu", 1e-8);
    defineConstant("basename", name + "_test");
    defineConstant("datadir", 'tests/');
  } else {
     // note: new change, group all the sim seed subdirs into a sims/ directory
     defineConstant("datadir", '../../data/slim_sims/'+name+'/sims/'+subdir_);
  }

  if (!fileExists(datadir)) {
    stop("output directory does not exist!");
  }

  // we need an L that if L = 0, it doesn't try to use that (since handled by selcoef)
  defineConstant("safeL", max(1, L));

  defineConstant("region_length", tracklen + safeL);
  cat(paste("region_length: ", region_length, "\n"));
  // We fix h = 0.5 and calculate the proper homozygous selection
  // coefficient.
  defineConstant("h", 0.5);
  defineConstant("s", sh / h);

  // == Runtime settings
  defineConstant("burnin", 10*N);
  defineConstant("endsim", burnin);

  // record subs
  defineConstant("subs", integer(10*N));

  metadata.setValue("N", N);
  metadata.setValue("sh", sh);
  metadata.setValue("s", s);
  metadata.setValue("h", h);
  metadata.setValue("mu", mu);
  metadata.setValue("rf", rf);
  metadata.setValue("rbp", rbp);
  metadata.setValue("tracklen", tracklen);
  metadata.setValue("L", L);
  metadata.setValue("region_length", region_length);
  if (exists("rep"))
    metadata.setValue("rep", rep);

  // == File Output
  // this must be the same order as the bgs_params in the Snakefile
  //params = c('N', 'mu', 'sh', 'rf', 'rbp', 'L', 'seed');
  //if (exists("rep")) {
  //params = c(params, 'rep');
  //}
  //filestr = filename_str(params);
  //defineConstant("basename", name + "_" + filestr);
  defineConstant("treeseq_file", datadir + basename + "_treeseq.tree");

  // == Mutations, Regions, and Recombination
  initializeMutationRate(mu);
  
  initializeMutationType("m1", h, "f", 0.0);
  if (L == 0) {
    selcoef = 0; // mimic L = 0 with s
  } else {
    selcoef = s;
  }
  // segment deleterious mutations
  initializeMutationType("m2", h, "f", -selcoef);
  // stacking policy: if a recurrent mutation happens, ignore it if one exists
  // NOTE: this was added after some apparent bias in B from
  // the stacking policy
  m2.mutationStackPolicy = "f";
  

  // Neutral tracked region from [0, tracklen-1] with no mutation
  // followed by a 1bp spacer (this is a bit silly but we don't want any
  // mutation or recombination in that 1bp)

  // gene segment under selection
  //initializeGenomicElementType("g1", m1, 1);
  initializeGenomicElementType("g2", m2, 1);
  //initializeGenomicElement(g1, 0, tracklen-1);
  initializeGenomicElement(g2, tracklen, tracklen+safeL-1);

  // recombination between segments
  // recombination between each bp from 0 to tracklen-1 is 0,
  // recombinaton rate between the basepair tracklen-1 / tracklen is rf,
  // recombinaton rate between tracklen / tracklen+1, tracklen+1 / tracklen+2, etc is rbp
  rec_rates = c(0, rf, rbp);
  rec_bins = c(tracklen-1,        // neutral region â€” this is tracklen-1 - 0 + 1 = tracklen long
               tracklen,          // free recombinaton spacer between tracking and purifying segment
               tracklen+safeL);       // selected region
  // print(rec_rates);
  // print(rec_bins);
  initializeRecombinationRate(rec_rates, rec_bins);
}

1 {
  // check that the selected length is really the length we want
  // in zero-indexed right inclusive systems, length is e-s+1
  seg_length = element_length(sim.chromosome.genomicElements[0]);
  assert(seg_length == safeL, "actual segment length does not match specified length (L or safeL)");
  //track_length = element_length(sim.chromosome.genomicElements[0]);
  //assert(track_length == tracklen, "actual tracking length does not match expected length (tracklen)");
  //print(paste(region_length, sim.chromosome.genomicElements[1].endPosition));
  //print(paste("bob", region_length,  sim.chromosome.genomicElements[1].endPosition));
  // why + 1 at the end? SLiM is 0-indexed so the last position + bp 0 = total length.
  assert(region_length == sim.chromosome.genomicElements[0].endPosition+1);

  sim.addSubpop("p1", N);
  sim.rescheduleScriptBlock(s1, start=2, end=burnin);
  sim.rescheduleScriptBlock(s2, start=endsim, end=endsim);
}

s1 {
  // if (sim.generation % N == 0) 
  //   print(sim.generation);
  subs[sim.generation-1] = length(sim.substitutions);
}

s2 late() {
  // how many del mutations fixed?
  inds = p1.individuals;
  ndel_subs = length(sim.substitutions.mutationType == m2);
  fixed_load = sum(sim.substitutions[sim.substitutions.mutationType == m2].selectionCoeff);
  metadata.setValue("subs", subs);
  metadata.setValue("ndel_subs", sum(ndel_subs));
  metadata.setValue("fixed_load", sum(fixed_load));
  metadata.setValue("generations", sim.generation);
  popfit = pop_fitness(m2);
  metadata.setValue("Ef", mean(popfit));
  metadata.setValue("Vf", var(popfit));
  //print(treeseq_file);
  sim.treeSeqOutput(treeseq_file, metadata=metadata);
}

