import sys
from os.path import join
from bgspy.slim import SlimRuns

if not len(config):
    raise ValueError("config file not specified on command line, use --configfile config.json")


# --- slim sims --- 
run = SlimRuns(config)
name = run.name
basedir = run.basedir
bmaps = config['mle']['bmaps']

# this is the target neutral level of diversity,
# for mutations overlaid on trees. 
target_neut_pi = config['target_neut_pi']

# we also need another set of paths that correspond
# to the 'synthetic' fits that combine all chromosomes
# (on same replicate number). This is tricky, since
# the variable chrom entry is now fixed, and merging
# chromosomes but only for same sh/mu. The easiest way 
# is to copy the config and make the synthetic param 
# manually
synthetic_chroms = config['mle']['synthetic']
synthetic_config = copy.copy(config)
new_variable = dict()
for param, param_list in synthetic_config['variable'].items():
    if param != 'chrom':
        new_variable[param] = synthetic_config['variable'][param]
    else:
        new_variable['synthetic'] = ['_'.join(synthetic_chroms)]
synthetic_config['variable'] = new_variable
synthetic_config['simdir'] = None
synthetic_run = SlimRuns(synthetic_config)


windows = config['mle']['windows']

# generate all the targets for this YAML file.
sim_results = run.generate_targets()

## useful for debugging:
#print("all targets:")
#print(sim_results) 
#print("template:")
#print(run.output_template()) 
#print("slim call:")
#print(run.slim_cmd())

rule slim:
    input: run.script, **run.input
    output: **run.output_template()
    resources:
      time_min=7200,
      mem_mb=20000
    shell: run.slim_cmd()


# --- empirical B --- 
rule empirical_B:
    input: files=sim_results, dir=run.simdir
    output: pkl=join(run.basedir, 'empirical_B', 'empirical_Bs.pkl')
    resources:
      mem_mb=40000,
      threads=40
    shell:
        """
        python ../../tools/process_sims.py {input.dir} {output.pkl} --ncores {resources.threads}
        """


# --- B map for sims ---
bmap_pattern = "bmap__{name}.pkl"


def get_bmap_input(wildcards):
  input = bmaps[wildcards.name]
  seqlens, recmap, annot = input['seqlens_file'], input['recmap_file'], input['annot_file']
  return dict(seqlens=seqlens, recmap=recmap, annot=annot)


rule bmap:
  input: unpack(get_bmap_input)
  output: pkl_b_file=join(run.basedir, 'bmaps/N__{N}/chrom__{chrom}', bmap_pattern)
  params: step=lambda w: bmaps[w.name]['step'], grid=lambda w: bmaps[w.name]['grid']
  resources:
    mem_mb=200000,
    time_min=4320,
    threads=30
  shell:
    """
    bgspy calcb \
      --recmap {input.recmap} --annot {input.annot} \
      --seqlens {input.seqlens} --t '{params.grid}' \
      --output {output} --popsize {wildcards.N} \
      --chrom {wildcards.chrom} \
      --ncores {threads} --ncores-Bp {threads} \
      --step {params.step}
    """


rule bmap_synthetic:
  input: unpack(get_bmap_input)
  output: pkl_b_file=join(run.basedir, 'bmaps/N__{N}/synthetic', bmap_pattern)
  params: grid=lambda w: bmaps[w.name]['grid'], step=100000, chrom_args=' '.join([f'--chrom {x} ' for x in synthetic_chroms])
  resources:
    mem_mb=200000,
    time_min=4320,
    threads=30
  shell:
    """
    bgspy calcb \
      --recmap {input.recmap} --annot {input.annot} \
      --seqlens {input.seqlens} --t '{params.grid}' \
      --output {output} --popsize {wildcards.N} \
     {params.chrom_args} \
      --ncores {resources.threads} --ncores-Bp {resources.threads} \
      --step {params.step}
    """


rule bmap_genome:
  input: unpack(get_bmap_input)
  output: pkl_b_file=join(run.basedir, 'bmaps/N__{N}/genome', bmap_pattern)
  params: grid=lambda w: bmaps[w.name]['grid'], step=lambda w: bmaps[w.name]['step']
  resources:
    mem_mb=90000,
    time_min=4320,
    threads=70
  shell:
    """
    bgspy calcb \
      --recmap {input.recmap} --annot {input.annot} \
      --seqlens {input.seqlens} --t '{params.grid}' \
      --output {output} --popsize {wildcards.N} \
      --ncores {resources.threads} --ncores-Bp {resources.threads} \
      --step {params.step}
    """

# --- mle --- 
access_file = config['mle']['input']['access_file']
neut_file = config['mle']['input']['neut_file']


# main fit results
fit_nreps = 50
mle_results = []
for bmap_name in bmaps:
    for window in windows:
        mle_dir = join('mle', bmap_name, str(window))
        #mle_data = run.generate_targets(suffices={'data': 'data.pkl'},
        #                                outdir=mle_dir,
        #                                nreps=fit_nreps, reseed=True)
        #mle_results.extend(mle_data)
        #mle_fits = run.generate_targets(suffices={'fit': 'mle.pkl'},
        #                                outdir=mle_dir,
        #                                nreps=fit_nreps, reseed=True)
        #mle_results.extend(mle_fits)
        syn_data = synthetic_run.generate_targets(suffices={'data': 'data.pkl'},
                                                  outdir=mle_dir,
                                                  nreps=fit_nreps, reseed=True)
        mle_results.extend(syn_data)
        syn_mle_fits = synthetic_run.generate_targets(suffices={'fit': 'mle.pkl'},
                                                       outdir=mle_dir,
                                                       nreps=fit_nreps, reseed=True)
        mle_results.extend(syn_mle_fits)
       


bmap_output = []
all_Ns = set(config['variable']['N'])
for bmap in bmaps:
    for N in all_Ns:
        bmap_output.append(join(run.basedir, f"bmaps/N__{N}/genome/bmap__{bmap}.pkl"))

#print("syn data")
#print(syn_data)

rule mle_data:
  input: **run.output_template(suffices={'tree_file': 'treeseq.tree'}),
         bs_file=join(run.basedir, 'bmaps/N__{N}/chrom__{chrom}/bmap__{bmap}.pkl')
  output: **run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'data.pkl'})
  resources:
    mem_mb=10000
  params: sim_mu=lambda w: target_neut_pi / (4*float(w.N))
  shell:
    """
    bgspy simdata --bs-file {input.bs_file} --chrom {wildcards.chrom} \
      --window {wildcards.window} --sim-mu {params.sim_mu} \
      --output {output.pkl} \
      {wildcards.chrom}={input.tree_file} \
    """

pattern = run.output_template(suffices={'tree_file': 'treeseq.tree'})
#print(expand(pattern['tree_file'], chrom=synthetic_chroms, allow_missing=True))

#print(synthetic_run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'data.pkl'}, pin_params={'synthetic': '-'.join(synthetic_chroms)}))

rule mle_data_multichrom:
  input: trees=expand(pattern['tree_file'], chrom=synthetic_chroms, allow_missing=True),
         bs_file=join(run.basedir, 'bmaps/N__{N}/synthetic/bmap__{bmap}.pkl'), access=access_file, neut=neut_file
  output: **synthetic_run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'data.pkl'}, pin_params={'chrom': 'synthetic'})
  resources:
    mem_mb=50000
  params: sim_mu=lambda w: target_neut_pi / (4*float(w.N))
  shell:
    """
    bgspy simdata --bs-file {input.bs_file} \
      --window {wildcards.window} --sim-mu {params.sim_mu} \
      --access {input.access} --neutral {input.neut} \
      --output {output.pkl} \
      {input.trees} \
    """


rule mle_fit:
  input: **run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'data.pkl'})
  output: **run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'mle.pkl'})
  resources:
    mem_mb=10000,
    time_min=300,
    threads=40
  params: nstarts=1000
  shell:
    """
    bgspy fit --data {input.pkl} --nstarts {params.nstarts} --output {output.pkl} --ncores {resources.threads}
    """

rule mle_synthetic_fit:
  input: **synthetic_run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'data.pkl'})
  output: **synthetic_run.output_template(outdir='mle/{bmap}/{window}', suffices={'pkl': 'mle.pkl'})
  resources:
    mem_mb=10000,
    time_min=300,
    threads=40
  params: nstarts=1000
  shell:
    """
    bgspy fit --data {input.pkl} --nstarts {params.nstarts} --output {output.pkl} --ncores {resources.threads}
    """


rule all:
    input: sim_results, mle_results

rule bmaps: 
    input: bmap_output
