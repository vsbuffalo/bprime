import sys
import json
from math import floor, log10
import itertools 
import numpy as np
import pyslim
import tskit
import msprime
from datetime import time
from collections import defaultdict, namedtuple

def filename_pattern(base, params, seed=False, rep=False):
  param_str = [v + '{' + v + '}' for v in params]
  if seed:
    param_str.append('seed{seed}')
  if rep:
    param_str.append('rep{rep}')
  pattern = base + '_'.join(param_str) + '_{{output}}'
  return pattern

def slim_call(params, slim_cmd="slim", rep=False, seed=True, manual=None):
  call_args = []
  for p, (lower, upper, log10, type) in params.items():
    is_str = type is str
    val = f"{{wildcards.{p}}}" if not is_str else f'\\"{{wildcards.{p}}}\\"'
    call_args.append(f"-d {p}={val}")
  if rep:
    call_args.append("-d rep={wildcards.rep}")
  add_on = ''
  if manual is not None:
    # manual stuff
    add_on = []
    for key, val in manual.items():
      if isinstance(val, str):
        add_on.append(f'-d {key}=\\"{val}\\"')
      else:
        add_on.append(f'-d {key}={val}')
    add_on = ' ' + ' '.join(add_on)
  if seed:
    call_args.append("-s {wildcards.seed}")
  full_call = f"{slim_cmd} " + " ".join(call_args) + add_on
  return full_call

def signif(x, digits=4):
  return np.round(x, digits-int(floor(log10(abs(x))))-1)

class UniformSampler(object):
    def __init__(self, ranges, total=None, seed=None, add_seed=True, 
                 seed_max=2**32, signif_digits=4):
        self.seed = seed
        self.add_seed = add_seed
        self.seed_max = seed_max
        self.rng = np.random.default_rng(seed)
        self.ranges = ranges
        self.total = total
        self.samples_remaining = total
        self.samples = []
        self.signif_digits = signif_digits

    def __iter__(self):
        return self

    @property
    def __len__(self):
        return len(self.samples)

    def __next__(self):
        if self.total is not None and self.samples_remaining == 0:
            raise StopIteration
        assert(self.samples_remaining >= 0)
        param = {}
        for key, (lower, upper, log10, type) in self.ranges.items():
            if lower == upper:
                # fixed parameter
                val = lower
                if log10:
                    val = 10**lower
                param[key] = val
                continue
            # log10 or floats get uniform float
            if type is float or log10:
                sample = self.rng.uniform(lower, upper)
            elif type is int and not log10:
                # if the type is int and not log10, discrete uniform
                sample = self.rng.integers(lower, upper)
            else:
                raise ValueError("type must be float or int")
            if log10:
                sample = signif(10**sample, self.signif_digits)
            if type is int:
                sample = int(sample)
            else:
                sample = signif(sample, self.signif_digits)
            param[key] = sample
        if self.add_seed:
            seed = self.rng.integers(0, self.seed_max)
            param['seed'] = seed
 
        self.samples_remaining -= 1
        self.samples.append(param)
        return param

    def __repr__(self):
        rows = [f"UniformSampler with {self.samples_remaining}/{self.total} samples remaining, seed={self.seed}"]
        for key, (lower, upper, log10, type) in self.ranges.items():
            scale = 'linear'
            if log10:
               scale = 'log10'
            type_str = {float: 'float', int: 'int'}[type]
            if isinstance(lower, float) or isinstance(upper, float):
                lower, upper = [signif(lower, self.signif_digits), signif(upper, self.signif_digits)]
            row = f"{key} âˆˆ [{lower}, {upper}] ({scale}, {type_str})"
            rows.append(row)
        return "\n".join(rows)


def read_params(config):
  params = {}
  for param, vals in config['params'].items():
    lower, upper = vals['lower'], vals['upper']
    log10, type = vals['log10'], {'float': float, 'int': int}[vals['type']]
    params[param] = (lower, upper, log10, type)
  return params
  

# ------- Shared Parameters -------
DATADIR = "../data/slim_sims/"
SLIM = '~/src/SLiM_build/slim'
 
# ------- BGS segments -------
#bgs_ranges = dict(N=(50, 20_000, False, int),
#                  mu=(1e-9, 1e-7, False, float), 
#                  h=(0.5, 0.5, False, float), 
#                  s=(1e-5, 1e-1, False, float), 
#                  rbp=(0.01/1e8, 30/1e8, False, float),
#                  recfrac=(-9, np.log10(0.5), True, float), # Morgans,
#                  seglen=(10, 10_000, False, int)) 

run_params = read_params(config)

sampler = UniformSampler(run_params, total=config['nsamples'], seed=12)
samples = list(sampler)

basename = DATADIR + f"{config['name']}/{config['name']}_"
pattern = filename_pattern(basename, run_params, rep=False, seed=True)

# bgs simulation results
sim_results = []
recap_results = []

# for use if there are more than one sim output files, e.g. log files
sim_outputs = ["treeseq.tree"]
for sample in samples:
  for out in sim_outputs:
    sim_results.append(pattern.format(**sample).format(output=out))
  recap_results.append(pattern.format(**sample).format(output='recap.tree'))

def time_grower(start_time, factor=1.8):
  def time_limit(wildcards, attempt):
      new_time = start_time*(attempt + factor*(attempt-1))
      days = int(new_time // 24)
      time_left = new_time % 24
      hours = int(time_left // 1)
      minutes = int(60*(time_left - (time_left // 1)))
      return f"{days:02d}-{hours}:{minutes}:00"
  return time_limit

rule bgs:
  input: "segment.slim"
  output: [pattern.replace("{{output}}", out) for out in sim_outputs]
  resources: 
    # 1.5 hours that grows 1.8x each failed attempt
    runtime = time_grower(config['init_runtime'])
  run:
    shell(slim_call(run_params, SLIM, rep=False, manual={'config_name': config['name']}) + " {input} ")

rule recap:
  input: treeseq=pattern.replace("{{output}}", 'treeseq.tree')
  output: recap=pattern.replace("{{output}}", 'recap.tree')
  #resources:
  #  time = "00-00:30:00"
  run:
    ts = pyslim.load(input.treeseq)
    md = ts.metadata['SLiM']['user_metadata']
    rts = pyslim.recapitate(ts, recombination_rate=0,
                            ancestral_Ne=md['N'][0]).simplify()
    rts.dump(output.recap)

rule all:
  input:
    sim_results, recap_results
    

