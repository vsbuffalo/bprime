import sys
from math import floor, log10
import itertools 
import numpy as np
import pyslim
import tskit
import msprime
from collections import defaultdict, namedtuple

def filename_pattern(base, params, seed=False, rep=False):
  param_str = [v + '{' + v + '}' for v in params]
  if seed:
    param_str.append('seed{seed}')
  if rep:
    param_str.append('rep{rep}')
  pattern = base + '_'.join(param_str) + '_{{output}}'
  return pattern

def slim_call(params, slim_cmd="slim", rep=False):
  call_args = []
  for p in params:
    is_str = isinstance(params[p][0], str) and params[p][0] not in ['T', 'F']
    val = f"{{wildcards.{p}}}" if not is_str else f'\\"{{wildcards.{p}}}\\"'
    if p == 'seed':
      call_args.append(f"-s val")
    else:
      call_args.append(f"-d {p}={val}")
  if rep:
    call_args.append("-d rep={wildcards.rep}")
  return f"{slim_cmd} " + " ".join(call_args)

def param_grid(seed=False, **kwargs):
  params = []
  for param, values in kwargs.items():
    if len(values):
      params.append([(param, v) for v in values])
    else:
      params.append([(param, '')])
  out = list(map(dict, itertools.product(*params)))
  if not seed:
    return out
  for entry in out:
    entry['seed'] = np.random.randint(0, 2**63)
  return out

def signif(x, digits=4):
  return np.round(x, digits-int(floor(log10(abs(x))))-1)

class UniformSampler(object):
    def __init__(self, ranges, total=None, seed=None, signif_digits=4, return_dict=True):
        self.seed = seed
        self.rng = np.random.default_rng(seed)
        self.ranges = ranges
        self.total = total
        self.samples_remaining = total
        self.samples = []
        self.signif_digits = signif_digits
        self.return_dict = return_dict

    def __iter__(self):
        return self

    @property
    def __len__(self):
        return len(self.samples)

    def __next__(self):
        if self.total is not None and self.samples_remaining == 0:
            raise StopIteration
        assert(self.samples_remaining >= 0)
        use_dict = self.return_dict
        if use_dict:
            param = {}
        else:
            param = []
        for key, (lower, upper, log10, type) in self.ranges.items():
            if lower == upper:
                # fixed parameter
                val = lower
                if log10:
                    val = 10**lower
                if use_dict:
                    param[key] = val
                else:
                    param.append(val)
                continue
            if type is int:
            	sample = self.rng.integers(lower, upper)
            elif type is float:
                sample = self.rng.uniform(lower, upper)
            else:
                raise ValueError("type must be int or float")
            if log10:
                sample = signif(10**sample, self.signif_digits)
            sample = signif(sample, self.signif_digits)
            if use_dict:
                param[key] = sample
            else:
                param.append(sample)
        self.samples_remaining -= 1
        self.samples.append(param)
        return param

    def __repr__(self):
        rows = [f"{self.samples_remaining}/{self.total} samples remaining, seed={self.seed}"]
        for key, (lower, upper, log10, type) in self.ranges.items():
            scale = 'linear'
            if log10:
               scale = 'log10'
            type_str = {float: 'float', int: 'int'}[type]
            if isinstance(lower, float) or isinstance(upper, float):
                lower, upper = [signif(lower, self.signif_digits), signif(upper, self.signif_digits)]
            row = f"{key} âˆˆ [{lower}, {upper}] ({scale}, {type_str})"
            rows.append(row)
        return "\n".join(rows)

# ------- Shared Parameters -------
DATADIR = "../data/slim_sims/"
NSAMPLES = 1000
NREPS = 500
SLIM = '~/src/SLiM_build/slim'
 
N_range = (1000, 1000, int, None)
mu_range = (1e-8, 1e-7, float, None)
h_range = (0.5, 0.5, float, None)
#rbp_range = (0.01/1e8, 30/1e8, float, None) # cM/Mbp
rbp_range = (1/1e8, 1/1e8, float, None) # cM/Mbp
#recfrac_range = (-9, np.log10(0.5), float, 'log10') # Morgans
recfrac_range = (-8, -8, float, 'log10') # Morgans
s_range = (-5, np.log10(0.2), float, 'log10')
seglen_range = (10000, 10000, int, None)

# ------- BGS segments -------
bgs_ranges = dict(N=(np.log10(50), 4, True, int),
                  mu=(-9, -7, True, float), 
                  h=(0.5, 0.5, False, float), 
                  s=(-5, -1, True, float), 
                  rbp=(0.01/1e8, 30/1e8, False, float),
                  recfrac=(-9, np.log10(0.5), True, float), # Morgans,
                  seglen=(10, 10_000, False, int)) 

bgs_sampler = UniformSampler(bgs_ranges, total=1_000_000, seed=12)
bgs_params = list(bgs_sampler)

bgs_basename = DATADIR + 'segment/segment_'
bgs_pattern = filename_pattern(bgs_basename, bgs_ranges, rep=False)

# bgs simulation results
bgs_sim_results = []
bgs_recap_results = []

# for use if there are more than one sim output files, e.g. log files
sim_outputs = ["treeseq.tree"]
for params in bgs_params:
  for out in sim_outputs:
    bgs_sim_results.append(bgs_pattern.format(**params).format(output=out))
  bgs_recap_results.append(bgs_pattern.format(**params).format(output='recap.tree'))

rule bgs:
  input: "segment.slim"
  output: [bgs_pattern.replace("{{output}}", out) for out in sim_outputs]
  shell:
    slim_call(bgs_ranges, SLIM, rep=False) + " {input} "

rule bgs_recap:
  input: treeseq=bgs_pattern.replace("{{output}}", 'treeseq.tree')
  output: recap=bgs_pattern.replace("{{output}}", 'recap.tree')
  run:
    ts = pyslim.load(input.treeseq)
    md = ts.metadata['SLiM']['user_metadata']
    rts = pyslim.recapitate(ts, recombination_rate=0,
                            ancestral_Ne=md['N'][0]).simplify()
    rts.dump(output.recap)

rule all:
  input:
    bgs_sim_results, bgs_recap_results
    

