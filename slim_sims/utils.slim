function (logical)contains(string x, string y) {
  assert(length(x) == 1 & length(y) == 1, "x and y must be length 1");
  return length(strsplit(x, y)) > 1;
}

function (object)mut(integer i) {
  if (length(i) == 1) 
    return executeLambda(format("m%d;", i));
  // build a vector of mutatin types.
  m_concat = "c(m" + paste(i, sep=", m") + ")";
  return executeLambda(m_concat + ";");
}

// Load in a TSV DFE file
// first line is:
//   grid        1e-1,1e-2,...
// next are:
//   feature     0.1,0.2,...
function (object)load_tsv_dfe(string _dfe_file) {
  dfe = Dictionary();
  dfe_map = Dictionary();
  first = T;
  for (line in readFile(_dfe_file)) {
    parts = strsplit(line, "\t");
    feature = parts[0];
    dist = asFloat(strsplit(parts[1], ","));
    if (first) {
      // get the grid
      assert(feature == "grid");
      selgrid = dist;
      print(selgrid);
      first = F;
      next;
    } else {
      assert(feature != "grid", "'grid' is reserved!");
    }
    assert(length(dist) == length(selgrid), feature + " has inconsistent length");
    dfe.setValue(feature, dist);
  }
  dfe.setValue("grid", selgrid);
  return dfe;
}

// Build up fixed-PMF DFE for the fatures in a BED file
// _annot_file: annotation BED file
// _dfe: dictionary of DFE entries
// _h: dominance coefficient
// _chrom: the chromosome being simulated (all other chroms 
//         in _annot_file are ignored)
function (void)initialize_genome_dfe(string _annot_file, object _dfe, float _h, string _chrom) {
  // ---- first build the mutation types for the DFE
  all_muts = c();
  selgrid = _dfe.getValue("grid");
  for (i in seqAlong(selgrid)) {
    initializeMutationType(i, h, "f", -selgrid[i]);
    all_muts = c(all_muts, i);
  }

  // ---- then build up the genomic element types 
  gene_els = Dictionary();
  ngeneltypes = 0;
  for (i in seqAlong(_dfe.allKeys)) {
    key = _dfe.allKeys[i];
    if (key == "grid")
      next;
    // make a genomic element for this feature type
    gx = paste0("g", i);
    // keep track of the features in a map
    gene_els.setValue(key, gx);
    // build the genomic element type, with proper discrete PMF
    // DFE
    initializeGenomicElementType(gx, all_muts,
                                 _dfe.getValue(key));
    ngeneltypes = ngeneltypes + 1;
  }

  // ---- finally, build up the genomic elements
  ngenes = 0;
  for (line in readFile(_annot_file)) {
    parts = strsplit(line, "\t");
    if (parts[0] != _chrom) {
      next;
    }
    start = asInteger(parts[1]);
    end = asInteger(parts[2]);
    key = parts[3];
    initializeGenomicElement(executeLambda(gene_els.getValue(key) + ';'), start, end-1);
    ngenes = ngenes + 1;
  }
  catn("initialized genomic element types: " + ngeneltypes);
  catn("initialized genomic elements: " + ngenes);
  catn("initialized mutation types: " + length(selgrid));
}

// Load a HapMap-formatted recombination map
function (void)load_recmap(string _recmap_file, string _chrom, integer _chrom_length) {
  // assumes cM/Mb rates 0.01 / 1e6
  bins = c();
  rates = c();
  for (line in readFile(_recmap_file)) {
    parts = strsplit(line, "\t");
    if (parts[0] == "Chromosome" | parts[0] != _chrom) {
      next; // skip HapMap header or chroms we aren't sim'ing
    }
    // rates are cM/Mbp per 100kb window
    rates = c(rates, 1e-8 * asFloat(parts[2]));
    bins = c(bins, asInteger(parts[1]));
  }
  bins = c(bins, _chrom_length-1);
  rates = c(rates, 0);
  initializeRecombinationRate(rates, bins);
  catn("initialized recrate bins: " + length(bins));
}

function (integer)get_chrom_length(string _seqlens_file, 
                                  string _chrom) {
  // get chromsome length from a TSV 'genome'
  // file of chromosome names and lengths
  chrom_length = -1;
  for (line in readFile(_seqlens_file)) {
    parts = strsplit(line, "\t");
    if (parts[0] == _chrom) {
      chrom_length = asInteger(parts[1]);
    }
  }
  assert(chrom_length > 1);
  return chrom_length;
}

function (string)filename_str(string params) {
  out = "";
  for (i in seqAlong(params)) {
    v = params[i];
    val = executeLambda(v + ";");
    if (isFloat(val)) {
      // float formatting correction to match python
      val = format("%g", val);
    }
    assert(!contains(asString(val), "..") & !contains(asString(val), "/"),
           "filename key/value cannot contain . or /!");
    out = out + v + val + "_";
  }
  return out;
}

function (integer)element_length(object el) {
  return el.endPosition - el.startPosition + 1;
}

function (object)param_dict(string params) {
  pd = Dictionary();
  for (i in seqAlong(params)) {
    v = params[i];
    val = executeLambda(v + ";");
    if (length(val) > 1) {
      val = paste(val, sep=",");
    }
    pd.setValue(v, val);
  }
  return pd;
}

function (float) standard_fitness(object ind, object mut_type) {
  muts = sim.mutationsOfType(mut_type);
  hh = mut_type.dominanceCoeff;
  ss = muts.selectionCoeff;
  nmuts1 = ind.genome1.mutationCountsInGenomes(muts);
  nmuts2 = ind.genome2.mutationCountsInGenomes(muts);
  muts = nmuts1 + nmuts2;
  hets = muts == 1;
  homs = muts == 2;
  return exp(sum(log(1 + hh*ss[hets])) + sum(log(1 + ss[homs])));
}

function (float) pop_fitness(object mut_type) {
  inds = sim.subpopulations.individuals;
  return sapply(inds, 'standard_fitness(applyValue, mut_type);');
}

function (void)output_mutations(string chrom, string filename, object subpop) {
  counts = sim.mutationCounts(subpop, mutations=sim.mutations);
  for (i in seqAlong(sim.mutations)) {
    mut = sim.mutations[i];
    row = paste(chrom, mut.position, 2*subpop.individualCount, counts[i], mut.selectionCoeff, mut.mutationType.dominanceCoeff, sep="\t");
    writeFile(filename, row, append=T, compress=T);
  }
}

function (void)output_substitutions(string _chrom, string filename, object subpop) {
  for (i in seqAlong(sim.substitutions)) {
    sub = sim.substitutions[i];
    row = paste(_chrom, sub.position, sub.selectionCoeff, sub.mutationType, sub.mutationType.dominanceCoeff, sep="\t");
    writeFile(filename, row, append=T, compress=T);
  }
}

function (float) central_moment(numeric vals, integer n) {
  return mean((vals - mean(vals))^n);
}

function (float) ssh(object mut_type) {
  muts = sim.mutationsOfType(mut_type);
  inds = sim.subpopulations.individuals;
  f = sim.mutationFrequencies(NULL, muts);
  //Fc = sapply(inds, 'cov(asInteger(applyValue.genome1.containsMutations(muts)),asInteger(applyValue.genome2.containsMutations(muts)));');
  //if (isNULL(Fc))
  //Fc = 0;
  //return 2*sum(f*(1-f)) + 2*sum(Fc);
  return 2*sum(f*(1-f));
}


