"""
Main Snakemake-based model fitting pipeline.
"""
import socket
import numpy as np

## personal stuff for my project (sorry, safe to ignore)
# we scale down the number of cores if we're doing this on the cluster
clustername = 'talapas'
machine = 'cluster' if socket.gethostname().startswith(clustername) else None


## general stuff 
NSTARTS = 2_000
NSTARTS_LOO = 2_000

BLOCKSIZE = 25_000_000  # 25Mb ~1/10th of chr1

# note: ncores_loo is per-job;
# you'll want to account number of total jobs,
# -j
if machine == 'cluster':
    NCORES = 40
    NCORES_LOO = NCORES
else:
    # just blast through a bunch without parallel snakemake jobs
    NCORES = 70
    NCORES_LOO = 70

CHROMS = [f'chr{x}' for x in range(1, 23)]

# from config
name = config["name"]
mu = config.get("mu", None)
seqlens_file = config["seqlens_file"]
recmap_file = config["recmap_file"]
access_file = config["access_file"]
neut_file = config["neut_file"]
fasta_file = config["fasta_file"]
counts_dir = config["counts_dir"]
Bs_file = config["Bs_file"]
windows = [int(w) for w in config["windows"]]
#blocksize = int(config["blocksize"])

# the data that goes into the likelihood model
model_data = [f'model_data_{w}.pkl' for w in windows]

rule save_data:
  # only get the data, e.g. for testing, for this model
  input: seqlens=seqlens_file, recmap_file=recmap_file,
         access_file=access_file, fasta_file=fasta_file,
         neut_file=neut_file, counts_dir=counts_dir,
         bs_file=Bs_file
  output: 'model_data_{window}.pkl'
  params: name=name
  shell:
    """
    mkdir -p {params.name}
    bgspy data --seqlens {input.seqlens} --recmap {input.recmap_file} \
      --counts-dir {input.counts_dir} --neutral {input.neut_file} \
      --access {input.access_file} --bs-file {input.bs_file} \
      --window {wildcards.window} \
      --fasta {input.fasta_file} \
      --output {output[0]}
    """

rule fit:
  input: 'model_data_{window}.pkl'
  output: 'fit_{window}/mle.pkl'
  params: ncores=NCORES, nstarts=NSTARTS, mu=mu, name=name
  shell:
    """
    mkdir -p {params.name}
    bgspy fit \
      --data {input[0]} \
      --ncores {params.ncores} --nstarts {params.nstarts} \
      --output {output[0]}
    """

# rule jackknife:
#   input: fit='fit_{window}/mle.pkl', 
#   output: 'fit_{window}/jackknifes/jackknifes_{boot}.npz'
#   params: ncores=NCORES_JK, nstarts=NSTARTS_JK, blocksize=blocksize
#   shell:
#     """
#     bgspy jackknife --fit {input.fit} \
#       --B {params.ncores} --blocksize {params.blocksize} \
#       --ncores {params.ncores} --nstarts {params.nstarts} \
#       --outfile {output[0]}
#     """

rule block_jackknife:
  # note that this doesn't actually require fit object, but 
  # I prefer that gets calculated first
  input: data='model_data_{window}.pkl', fit='fit_{window}/mle.pkl'
  output: 'fit_{window}/jackknife/jackknife_{frac}.pkl'
  params: ncores=NCORES_LOO, nstarts=NSTARTS_LOO
  shell:
    """
    bgspy jackblock \
      --blockwidth {BLOCKSIZE} \
      --data {input.data} \
      --output {output[0]} \
      --blockfrac {wildcards.frac}
      --ncores {params.ncores} --nstarts {params.nstarts}
    """


rule loo_chrom:
  # note that this doesn't actually require fit object, but 
  # I prefer that gets calculated first
  input: data='model_data_{window}.pkl', fit='fit_{window}/mle.pkl'
  output: 'fit_{window}/loo/loo_{chrom}.pkl'
  params: ncores=NCORES_LOO, nstarts=NSTARTS_LOO
  shell:
    """
    bgspy jackchrom \
      --data {input.data} \
      --output {output[0]} \
      --chrom {wildcards.chrom} \
      --ncores {params.ncores} --nstarts {params.nstarts}
    """

# the data needed for all fits in this model
loo_results = []
jk_results = []
mle_results = []
boots_results = []
for window in windows:
  mle_results.append(f'fit_{window}/mle.pkl')
  # chromosome-level LOO for R2, etc
  for chrom in CHROMS:
      loo = f"fit_{window}/loo_chrom/loo_{chrom}.pkl"
      loo_results.append(loo)
  # block-level jackknife
  for frac in np.linspace(0, 1, 1000):
      frac = np.round(frac, 4)
      jk_results.append(f'fit_{window}/jackknife/jackknife_{frac}.pkl')
    

rule mle:
  input: mle_results

rule jackknife:
  input: mle_results, jk_results

rule loo:
  input: mle_results, loo_results

rule data:
  input: model_data
