

rule cpg:
  output: "cpgIslandExt.txt.gz"
  shell:
    """
    wget http://hgdownload.cse.ucsc.edu/goldenPath/hg38/database/cpgIslandExt.txt.gz
    """

rule cpg_bed:
  input: "cpgIslandExt.txt.gz"
  output: "cpg_islands.bed.gz"
  shell:
    """
    zcat {input} |  bioawk -t '{{ print $2,$3,$4,"cpg_island" }}' | gzip > {output}
    """


rule mask:
  input: cpg="cpg_islands.bed.gz", mask="repeat_masker.bed.gz"
  output: "repeat_cpg_mask.bed.gz"
  shell:
    """
    (zcat {input.mask} | bioawk -t '{{ print $1,$2,$3,"repeat_mask"}}'; zcat {input.cpg}) | sort -k1,1 -k2,2n | bedtools merge | gzip > {output} 
    """

rule multiz17:
  output: "hg38.17way.maf.gz"
  shell:
     """
     wget http://hgdownload.cse.ucsc.edu/goldenPath/hg38/multiz17way/hg38.17way.maf.gz
     """

# version with sliding mask splitter 
#./MafFilter/maffilter input.file.compression=gzip 'maf.filter=Subset(species=(ponAbe2,hg38,panTro4,panPan1,gorGor3), strict=yes,remove_duplicates=yes),SelectChr(ref_species=hg38,chromosome={wildcards.chrom}),Output(file={output}),MaskFilter(species=hg38,window.size=10,window.step=1,max.masked=2)' input.file={input}
rule split_multiz17:
  input: "hg38.17way.maf.gz"
  output: "multiz17_filtered/{chrom}.maf"
  shell:
     """
     ./MafFilter/maffilter input.file.compression=gzip 'maf.filter=Subset(species=(ponAbe2,hg38,panTro4,panPan1,gorGor3), strict=yes,remove_duplicates=yes),SelectChr(ref_species=hg38,chromosome={wildcards.chrom}),Output(file={output})' input.file={input}
     """

rule intron_gff:
  input: bed="../annotation/hg38.ensembl_introns.bed.gz"
  output: "hg38.ensembl_introns.gff"
  shell:
    """
    zcat {input.bed} | awk 'BEGIN{{OFS="\t"}} {{print $1, ".", "intron", $2+1, $3, ".", "+", ".", "ID="NR}}' > {output}
    """

rule neutral_gff:
  input: bed="../fit_annotation/putatively_neutral.bed.gz"
  output: "hg38.putatively_neutral.gff"
  shell:
    """
    zcat {input.bed} | \
      awk 'BEGIN{{OFS="\t"}} {{print $1, ".", "neutral", $2+1, $3, ".", "+", ".", "ID="NR}}' > {output}
    """

rule gff_with_introns_neutral:
  input: gff="../annotation/hg38.ensembl.gff3.gz", introns="hg38.ensembl_introns.gff", neutral="hg38.putatively_neutral.gff"
  output: "hg38.ensembl_with_introns_neutral.gff"
  shell:
    """
    (zcat {input.gff}; cat {input.introns} {input.neutral}) | sort -k1,1 -k4,4n > {output}
    """

# This is tedious, but we need to give phylofit the cleanest GFF possible, 
# e.g. no overlapping ranges so basepairs doesn't accidentally get double counted.
# (I'm not sure whether phylofit does a merge, so we do it)
# The merge must be **feature** specific though, hence why we split all features
# We also subtrack the mask (CpG + repeat masker)
rule merge_features:
  input: feats="hg38.ensembl_with_introns_neutral.gff", mask="repeat_cpg_mask.bed.gz"
  output: "gff_features/hg38.ensembl_{feature}.gff"
  shell: 
    """
      awk 'BEGIN{{OFS="\t"}} {{ if ($3 == "{wildcards.feature}") {{ print $0 }}}}' {input} | bedtools merge | \
        bedtools subtract -a - -b {input.mask} | \
        awk 'BEGIN{{OFS="\t"}}{{print $1, ".", "{wildcards.feature}", $2+1, $3, ".", ".", ".", "."}}' > {output} 
    """

all_features = ['CDS', 'three_prime_UTR', 'five_prime_UTR',
                'intron', 'neutral', 'pseudogene']

# now, we need to merge all features again
rule merged_gff:
  input: [f"gff_features/hg38.ensembl_{f}.gff" for f in all_features]
  output: "hg38.ensembl_with_introns_neutral_merged_masked.gff"
  shell:
     """
     cat {input} | sort -k1,1 -k4,4n > {output}
     """

## Now, we split by chromosome (makes parallelization possible)
rule split_gff:
  #input: "../annotation/hg38.ensembl.gff3.gz"
  input: "hg38.ensembl_with_introns_neutral_merged_masked.gff"
  output: "gff_by_chrom/hg38.ensembl_{chrom}.gff"
  shell: 
    """
    cat {input} | bioawk -cgff '$seqname~/{wildcards.chrom}/ {{ print $0 }}' | bioawk -cgff '$feature~/intron|neutral|CDS|five_prime_UTR|three_prime_UTR|pseudogene/ {{ print $0 }}' > {output[0]}
    """

# we also do phastcons regions, but separately
rule phastcons_no_cds_utr:
   # subtract out the genomic annotation features to mimic what B is calc'd on
   input: pc="../annotation/conserved_phastcons/{chrom}.bed", gff="gff_by_chrom/hg38.ensembl_{chrom}.gff"
   output: "../annotation/conserved_phastcons_no_cds/{chrom}.bed"
   shell:
     """
     bedtools subtract -a {input.pc} -b {input.gff} > {output[0]}
     """

rule maf_for_phastcons_no_cds_utrs:
   input: bed="../annotation/conserved_phastcons_no_cds/{chrom}.bed", maf="multiz17_filtered/{chrom}.maf"
   output: "mafs_by_feature/{chrom}.phastcons_no_cds_utr.maf"
   shell:
     """
     # the echo BS is because maf_parse is dropping the header for BEDs(!)
     (echo "##maf version=1"; maf_parse --features {input.bed} {input.maf}) > {output[0]}
     """

rule maf_for_phastcons:
   input: bed="../annotation/conserved_phastcons/{chrom}.bed", maf="multiz17_filtered/{chrom}.maf"
   output: "mafs_by_feature/{chrom}.phastcons.maf"
   shell:
     """
     # the echo BS is because maf_parse is dropping the header for BEDs(!)
     (echo "##maf version=1"; maf_parse --features {input.bed} {input.maf}) > {output[0]}
     """

# *Main* GFF->MAF (minus phastcons) use maf_parse to split out the MAFs per chrom also by feature
rule maf_by_feature:
   input: gff="gff_by_chrom/hg38.ensembl_{chrom}.gff", maf="multiz17_filtered/{chrom}.maf"
   output: "mafs_by_feature/{chrom}.CDS.maf", "mafs_by_feature/{chrom}.three_prime_UTR.maf", 
           "mafs_by_feature/{chrom}.intron.maf", 
           "mafs_by_feature/{chrom}.neutral.maf", 
           "mafs_by_feature/{chrom}.five_prime_UTR.maf", "mafs_by_feature/{chrom}.pseudogene.maf",
   shell:
     """
     maf_parse --features {input.gff} --by-category --out-root mafs_by_feature/{wildcards.chrom} {input.maf}
     """

rule phylofit_by_feature:
   input: "mafs_by_feature/{chrom_feature}.maf"
   output: "pfests_by_feature/{chrom_feature}.mod"
   shell:
     """
     TREE="(ponAbe2,((hg38,(panTro4,panPan1)),gorGor3))"
     phyloFit --tree $TREE --subst-mod UNREST --EM --precision MED --out-root pfests_by_feature/{wildcards.chrom_feature} {input}
     """

features = ['intron', 'neutral', 'five_prime_UTR', 
            'three_prime_UTR', 'CDS', 
            'phastcons', 'phastcons_no_cds_utr']

ALL_FILES = []
for chrom_num in range(1, 23):
  chrom = f"chr{chrom_num}"
  for feat in features:
    ALL_FILES.append(f"pfests_by_feature/{chrom}.{feat}.mod")

rule all:
  input: ALL_FILES
